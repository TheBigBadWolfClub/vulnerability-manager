# Vulnerability Challenge

## How to run

Requirements:

- docker-compose

The root of the project contains the docker and docker-compose files;

docker-compose.yml will start 3 docker containers:

- 1 - webapp - will start nodejs to serve API and static web pages
    - it will also restore data to mongoDB
- 2 - mongoexpress - UI interface for mongoDB
- 3 - mongo - the mongoDB instance

To run all instances:

```
 docker-compose build && docker-compose up -d
```

To Login in webapp or mongoexpress: admin:admin

- webapp: http://<docker_addr>:8080
- mongoexpress: http://<docker_addr>:8081

## Implementation details

While implementing this app, I took the opportunity to learn new frameworks.

- React
- GraphQl

Missing:

- image upload
- no correlation between users and vulnerabilities
- all users in the system have the same permissions
- This more of a vulnerability library, and does not have integration with customers

### Stack

- NodeJs
- MongoDb
- Grapql
- React

### Specifications

This app has been designed has a Vulnerability library, where users can:

- Add a new vulnerability
- List all vulnerabilities
- Edit a vulnerability
- Delete a vulnerability
- View some graphical representation of CVSS scores of all vulnerabilities

### API

The API has been implemented using GraphQl, this gives frontend developers the ability to make custom requests.

This is very different from Rest Api's, in GraphQl only one end point exists and all requests are made using POST.

documents/local_queries.graphql, contains some examples used to develop this APP.

### Database

The database is composed by four collections:

- users: only used to authenticate user request to api
- vulnerabilities: to store details for a given vulnerability
    - id, name, description, evidences, preventions,  (id_cvsses, id_cvssscores)
- cvsees: to store CVSS information
- cvssscores: to store the calculation of CVSS

#### Relations:

The relation from the three collections is 1-1 (vulnerabilities, cvsses, cvssscores).

- All 3 have an ID entry to the corresponding document on the other collection.

This way and using Grapql, it was easy to query data, using an ID from any collection.

Example:

- vulnerability ID: a query to this collection, can be filled with information from any other collection
- cvsses ID: a query to this collection, can be filled with information from other any collection 
 

